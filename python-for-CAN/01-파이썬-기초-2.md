---
marp: true
footer: 2023 CAN 파이썬 스터디 - bit.ly/3oWarda
---

<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
</head>

# 지난 시간 Review

1. 자료형
2. 연산자
3. 흐름제어

---

# 원시 자료형 지도

<!-- ```mermaid
graph LR
    numeric[숫자]
    numeric --- |"음수, 0, 양수 | int"| Int(정수)
    numeric --- |"소수점 있는 실수 | float"| Float(실수)
    numeric --- |"허수 | complex"| Complex(허수)

    Character[문자/문자열] --- |"문자/문자열 | str"| String(문자/문자열)

    Logical[논리값] --- |"참과 거짓, True, False | bool"| Boolean(논리값)
``` -->

<center>
    <img src="https://mermaid.ink/img/pako:eNptkb9OAkEQxl9lstWRHNH6SjEkJlRid0ex3i1wyd0uWfYSDVBqLmqBf7GRUBgspMBoQcETces7OOvGSyRsM19m5vtNZmdAQhEx4pGOpL0uNI4DDvh4ljIZh77O3_V03PqXhGq1CsOA6JcbnT-7sO-CfrpFCUOIuQrIEI64cvTsEXOV3dZLY9WzMehpXlw9gL5-tYB2Iugvom6EY_O7Id-T3HpCkfYSdmZcNSsdW0Ofdda6VNJQMekXixUutGeDnny1_mjbBeT2lTTMppIx7zjbDSW8ITpxSBO_uFgX88VmeVcy9XK1-VzD5mOp3-5dOJEZc6FOkz5D-qkQicEfYGSUO6W9QlyCi6Y0jvAuAzMkIKrLUhYQD2XE2jRL8JMCPsJWminRPOch8ZThk6wXUcUOY4oXTYnXNuNGP2ECz_g?type=png" />
</center>

---

# 원시 자료형 알아보기 #1: 타입 변환

```python
실수_a: float = 3.141592
정수_a: int = int(3.141592)  # 3, int(원하는 숫자) 하면 정수로 결과 도출 
문자열_a: str = str(실수_a)  # "3.141592", str(원하는 변수) 하면 문자열로 변환된 결과 도출

# 안 되는 경우:
print(int("ABC"))  # "ABC"는 '정수'가 될 수 없기 때문에 오류 발생!
print(float("ABC"))  # float도 마찬가지!
```

`<원하는 타입>(<변환할 값>)` 형태로 사용하면, 대부분의 경우 변환이 원활히 이루어짐.
단, 안 되는 경우에는 오류가 발생하니 참고.

- 예시: `int(3.141592)`, `float("3.14")`, `str(310)`

---

# 원시 자료형 알아보기 #2: 타입 모르는 변수, 타입 특정하기
 
```python
정수A: int = 10
실수B: float = 3.141592

print(type(정수A))  # <class 'int'>
print(type(실수B))  # <class 'float'>

# 사용 예시: 변수 x가 무슨 타입이야?
x = 'str'
print(type(x))  # <class 'str'>

# 사용 예시: 변수 x는 str 타입이야?
x = 'str'
print(type(x) == str)  # True, 서로 일치하는 타입이면 True, 아니면 False!
```

---

# 복합 자료형 개요

- `list`: 원시, 복합 자료형을 여러 개 저장할 수 있는 자료형. `[`, `]` 괄호 사이에 `,`로 구분하여 값을 입력해서 선언
- `tuple`: 원시, 복합 자료형을 여러 개 저장할 수 있는 자료형. `(`, `)` 괄호 사이에 `,`로 구분하여 값을 입력해서 선언
- `set`: 원시 자료형을 중복 없이 저장할 수 있는 자료형. `{`, `}` 괄호 사이에 `,`로 구분하여 값을 입력해서 선언
- `dict`: `키-값` 짝 형식으로 값을 저장할 수 있는 자료형. `{`, `}` 괄호 사이에 `키:값` 형태로 값을 원하는 수만큼 `,`로 구분하여 선언

---

# 복합 자료형 `list`

<small>

다양한 값 저장할 수 있으면서 `[`, `]` 괄호 사이에 `,`로 구분하여 값을 입력해 선언함

**선언**

```python
리스트: list = [1, 2, 3]  # 각진 괄호 사이에 콤마(,)로 구분하여 선언
여러종류의값_저장가능: list = [1, '2', 3.141592, 3 - 2j, [1, 2, 3], ...]  # 여러 종류, 여러 개의 값 저장 가능
# 주의: 테스트 할 때 '...'은 빼주세요

# 내장 함수 #1: len
len(리스트)  # 3, 리스트 내 요소의 수 반환
len(여러종류의값_저장가능)

# 내부 값에 접근하는 법 (번짓수는 0번째부터 시작합니다)
# => 리스트의 번짓수는 0 ~ len(길이) - 1 입니다. 왜 그럴까요?
리스트[0]  # 0번째 값 접근하기
리스트[2]  # 2번째 값 접근하기

# 잘라내기, '슬라이싱' 하는 법
리스트[a:b]  # 슬라이싱 형식입니다: 이 경우 a번째부터 b-1번째까지 복사합니다.
리스트[0:2]  # [1, 2] | 0, 1번째 추출
리스트[1:]  # [1, 2] | 1번째부터 모두 추출
리스트[:1]  # [1] | 0번째부터 1-1번째(0)까지 추출
```

</small>

---

# 복합 자료형 `tuple`

**리스트와 똑같이** 다양한 값 저장할 수 있으면서, **최초 선언 이후 수정이 불가한** 자료형.
`(`, `)` 괄호 사이에 `,`로 구분하여 값을 입력해 선언함

**선언**

```python
튜플: tuple = (1, 2, 3)  # 둥근 괄호 사이에 콤마(,)로 구분하여 선언
여러종류의값_저장가능: tuple = (1, '2', 3.141592, 3 - 2j, [1, 2, 3], ...)  # 여러 종류, 여러 개의 값 저장 가능
# 주의: 테스트 할 때 '...'은 빼주세요

# 내장 함수 #1: len
len(튜플)  # 3, 튜플 내 요소의 수 반환
len(여러종류의값_저장가능)

# 내부 값에 접근하는 법 (번짓수는 0번째부터 시작합니다)
튜플[0]  # 0번째 값 접근하기
튜플[2]  # 2번째 값 접근하기

# 슬라이싱도 '똑같이' 사용할 수 있습니다!
```

---

# 복합 자료형 `set`

**중복 없이** 값을 저장할 수 있는, `(`, `)` 괄호 사이에 `,`로 구분하여 값을 입력해 선언함

<small>

**선언**

```python
집합: set = {1, 2, 3}  # 둥근 괄호 사이에 콤마(,)로 구분하여 선언
```

**주의점**

```python
# 1. 원시 자료형만 저장 가능
A: set = {[1, 2, 3]}  # 이런 식으로 리스트(복합 자료형)을 저장할 수 없음
# 2. 인덱싱, 번째 수 사용 불가
A[0], A[1]  # 왼쪽 코드처럼 0번째, 1번째의 개념이 없음.

# 번째수 사용하는 법:
list(A)[0]  # 리스트로 변환하는 동시에 번짓수 찾아보기

C = list(A)  # 특정 변수에 리스트로 변환한 값을 저장한 후,
C[0]  # 값 찾아보기
```

</small>

---

# 복합 자료형 `dict`

<small>

`키-값` 형태의 자료형을 저장하기 위한 자료형, `{`, `}` 괄호 사이에 `키:값` 형태로 저장할 값을 콤마 `,`로 구분하여 입력해 선언함

예시: '스포츠', '패션', '파이썬'으로 구분되는 블로그 글을 딕셔너리로 저장해보기

1. 블로그 글 분류를 '스포츠', '패션', '파이썬'으로 구분하여 저장한다고 하면 수학적으로 값을 2가지로 구분하여 $(\text{분류}, [\text{분류에 맞는 글 목록}])$ 으로  저장할 수 있음.

2. '스포츠', '패션', '파이썬' 3가지 분류로 구분하여 저장하면 최종적으로 아래와 같은 형식이 나옴:

$$
    \begin{pmatrix}
    (\text{스포츠}, [\text{스포츠 글 1}, \text{스포츠 글 2}, \dots, \text{스포츠 글 n}]) \\
    (\text{패션}, [\text{패션 글 1}, \text{패션 글 2}, \dots, \text{패션 글 n}]) \\
    (\text{파이썬}, [\text{파이썬 글 1}, \text{파이썬 글 2}, \dots, \text{파이썬 글 n}]) \\
    \end{pmatrix}
$$

</small>

---

$$
    \begin{pmatrix}
    (\text{스포츠}, [\text{스포츠 글 1}, \text{스포츠 글 2}, \dots, \text{스포츠 글 n}]) \\
    (\text{패션}, [\text{패션 글 1}, \text{패션 글 2}, \dots, \text{패션 글 n}]) \\
    (\text{파이썬}, [\text{파이썬 글 1}, \text{파이썬 글 2}, \dots, \text{파이썬 글 n}]) \\
    \end{pmatrix}
$$

3. 위 형식을 딕셔너리로 옮기면 아래와 같이 옮길 수 있음:

```python
블로그_글: dict = {
    "스포츠": ["스포츠 글 1", "스포츠 글 2", ..., "스포츠 글 n"],
    "패션": ["패션 글 1", "패션 글 2", ..., "패션 글 n"],
    "파이썬": ["파이썬 글 1", "파이썬 글 2", ..., "파이썬 글 n"]
}
```

---

```python
블로그_글: dict = {
    "스포츠": ["스포츠 글 1", "스포츠 글 2", ..., "스포츠 글 n"],
    "패션": ["패션 글 1", "패션 글 2", ..., "패션 글 n"],
    "파이썬": ["파이썬 글 1", "파이썬 글 2", ..., "파이썬 글 n"]
}
```

위 선언 코드를 사용하면 다음과 같이 코드를 작성할 수 있음

```python
# 1. '스포츠' 관련 게시글 찾아보기 (큰 따움표, 작은 따움표 여부는 무관합니다)
블로그_글["스포츠"]
블로그_글['스포츠']

# 2. '패션' 관련 게시글 찾아보기
블로그_글['패션']

# 3. '패션' 글을 3번째부터 가져오기
블로그_글['패션'][3:]

# 4. '패션' 분류의 2번째 글 수정하기
블로그_글['패션'][2] = "패션은 어려워"
```

---

# 연산자 지도

