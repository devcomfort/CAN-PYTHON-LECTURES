---
marp: true
paginate: true
footer: 2023 CAN 파이썬 스터디 - bit.ly/3oWarda
---

<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
</head>

# 지난 시간 Review

1. 자료형 (단순, 복합)
2. 연산자
3. 별 연산자
4. 흐름제어

---

# 원시 자료형 지도

<!-- ```mermaid
graph LR
    numeric[숫자]
    numeric --- |"음수, 0, 양수 | int"| Int(정수)
    numeric --- |"소수점 있는 실수 | float"| Float(실수)
    numeric --- |"허수 | complex"| Complex(허수)

    Character[문자/문자열] --- |"문자/문자열 | str"| String(문자/문자열)

    Logical[논리값] --- |"참과 거짓, True, False | bool"| Boolean(논리값)
``` -->

<center>
    <img src="https://mermaid.ink/img/pako:eNptkb9OAkEQxl9lstWRHNH6SjEkJlRid0ex3i1wyd0uWfYSDVBqLmqBf7GRUBgspMBoQcETces7OOvGSyRsM19m5vtNZmdAQhEx4pGOpL0uNI4DDvh4ljIZh77O3_V03PqXhGq1CsOA6JcbnT-7sO-CfrpFCUOIuQrIEI64cvTsEXOV3dZLY9WzMehpXlw9gL5-tYB2Iugvom6EY_O7Id-T3HpCkfYSdmZcNSsdW0Ofdda6VNJQMekXixUutGeDnny1_mjbBeT2lTTMppIx7zjbDSW8ITpxSBO_uFgX88VmeVcy9XK1-VzD5mOp3-5dOJEZc6FOkz5D-qkQicEfYGSUO6W9QlyCi6Y0jvAuAzMkIKrLUhYQD2XE2jRL8JMCPsJWminRPOch8ZThk6wXUcUOY4oXTYnXNuNGP2ECz_g?type=png" />
</center>

---

# 원시 자료형 알아보기 #1: 타입 변환

```python
실수_a: float = 3.141592
정수_a: int = int(3.141592)  # 3, int(원하는 숫자) 하면 정수로 결과 도출 
문자열_a: str = str(실수_a)  # "3.141592", str(원하는 변수) 하면 문자열로 변환된 결과 도출

# 안 되는 경우:
print(int("ABC"))  # "ABC"는 '정수'가 될 수 없기 때문에 오류 발생!
print(float("ABC"))  # float도 마찬가지!
```

`<원하는 타입>(<변환할 값>)` 형태로 사용하면, 대부분의 경우 변환이 원활히 이루어짐.
단, 안 되는 경우에는 오류가 발생하니 참고.

- 예시: `int(3.141592)`, `float("3.14")`, `str(310)`

---

# 원시 자료형 알아보기 #2: 타입 모르는 변수, 타입 특정하기
 
```python
정수A: int = 10
실수B: float = 3.141592

print(type(정수A))  # <class 'int'>
print(type(실수B))  # <class 'float'>

# 사용 예시: 변수 x가 무슨 타입이야?
x = 'str'
print(type(x))  # <class 'str'>

# 사용 예시: 변수 x는 str 타입이야?
x = 'str'
print(type(x) == str)  # True, 서로 일치하는 타입이면 True, 아니면 False!
```

---

# 복합 자료형 개요

- `list`: 원시, 복합 자료형을 여러 개 저장할 수 있는 자료형. `[`, `]` 괄호 사이에 `,`로 구분하여 값을 입력해서 선언
- `tuple`: 원시, 복합 자료형을 여러 개 저장할 수 있는 자료형. `(`, `)` 괄호 사이에 `,`로 구분하여 값을 입력해서 선언
- `set`: 원시 자료형을 중복 없이 저장할 수 있는 자료형. `{`, `}` 괄호 사이에 `,`로 구분하여 값을 입력해서 선언
- `dict`: `키-값` 짝 형식으로 값을 저장할 수 있는 자료형. `{`, `}` 괄호 사이에 `키:값` 형태로 값을 원하는 수만큼 `,`로 구분하여 선언

---

# 복합 자료형 `list`

<small>

다양한 값 저장할 수 있으면서 `[`, `]` 괄호 사이에 `,`로 구분하여 값을 입력해 선언함

**선언**

```python
리스트: list = [1, 2, 3]  # 각진 괄호 사이에 콤마(,)로 구분하여 선언
여러종류의값_저장가능: list = [1, '2', 3.141592, 3 - 2j, [1, 2, 3], ...]  # 여러 종류, 여러 개의 값 저장 가능
# 주의: 테스트 할 때 '...'은 빼주세요

# 내장 함수 #1: len
len(리스트)  # 3, 리스트 내 요소의 수 반환
len(여러종류의값_저장가능)

# 내부 값에 접근하는 법 (번짓수는 0번째부터 시작합니다)
# => 리스트의 번짓수는 0 ~ len(길이) - 1 입니다. 왜 그럴까요?
리스트[0]  # 0번째 값 접근하기
리스트[2]  # 2번째 값 접근하기

# 잘라내기, '슬라이싱' 하는 법
리스트[a:b]  # 슬라이싱 형식입니다: 이 경우 a번째부터 b-1번째까지 복사합니다.
리스트[0:2]  # [1, 2] | 0, 1번째 추출
리스트[1:]  # [1, 2] | 1번째부터 모두 추출
리스트[:1]  # [1] | 0번째부터 1-1번째(0)까지 추출
```

</small>

---

# 복합 자료형 `tuple`

**리스트와 똑같이** 다양한 값 저장할 수 있으면서, **최초 선언 이후 수정이 불가한** 자료형.
`(`, `)` 괄호 사이에 `,`로 구분하여 값을 입력해 선언함

**선언**

```python
튜플: tuple = (1, 2, 3)  # 둥근 괄호 사이에 콤마(,)로 구분하여 선언
여러종류의값_저장가능: tuple = (1, '2', 3.141592, 3 - 2j, [1, 2, 3], ...)  # 여러 종류, 여러 개의 값 저장 가능
# 주의: 테스트 할 때 '...'은 빼주세요

# 내장 함수 #1: len
len(튜플)  # 3, 튜플 내 요소의 수 반환
len(여러종류의값_저장가능)

# 내부 값에 접근하는 법 (번짓수는 0번째부터 시작합니다)
튜플[0]  # 0번째 값 접근하기
튜플[2]  # 2번째 값 접근하기

# 슬라이싱도 '똑같이' 사용할 수 있습니다!
튜플[a:b]
튜플[1:2]  (2)
튜플[1:]  # (2, 3)
```

---

# 복합 자료형 `set`

**중복 없이** 값을 저장할 수 있는, `(`, `)` 괄호 사이에 `,`로 구분하여 값을 입력해 선언함

<small>

**선언**

```python
집합: set = {1, 2, 3}  # 둥근 괄호 사이에 콤마(,)로 구분하여 선언
```

**주의점**

```python
# 1. 원시 자료형만 저장 가능
A: set = {[1, 2, 3]}  # 이런 식으로 리스트(복합 자료형)을 저장할 수 없음
# 2. 인덱싱, 번째 수 사용 불가
A[0], A[1]  # 왼쪽 코드처럼 0번째, 1번째의 개념이 없음.

# 번째수 사용하는 법:
list(A)[0]  # 리스트로 변환하는 동시에 번짓수 찾아보기

C = list(A)  # 특정 변수에 리스트로 변환한 값을 저장한 후,
C[0]  # 값 찾아보기
```

</small>

---

# 복합 자료형 `dict`

<small>

`키-값` 형태의 자료형을 저장하기 위한 자료형, `{`, `}` 괄호 사이에 `키:값` 형태로 저장할 값을 콤마 `,`로 구분하여 입력해 선언함

예시: '스포츠', '패션', '파이썬'으로 구분되는 블로그 글을 딕셔너리로 저장해보기

1. 블로그 글 분류를 '스포츠', '패션', '파이썬'으로 구분하여 저장한다고 하면 수학적으로 값을 2가지로 구분하여 $(\text{분류}, [\text{분류에 맞는 글 목록}])$ 으로  저장할 수 있음.

2. '스포츠', '패션', '파이썬' 3가지 분류로 구분하여 저장하면 최종적으로 아래와 같은 형식이 나옴:

$$
    \begin{pmatrix}
    (\text{스포츠}, [\text{스포츠 글 1}, \text{스포츠 글 2}, \dots, \text{스포츠 글 n}]) \\
    (\text{패션}, [\text{패션 글 1}, \text{패션 글 2}, \dots, \text{패션 글 n}]) \\
    (\text{파이썬}, [\text{파이썬 글 1}, \text{파이썬 글 2}, \dots, \text{파이썬 글 n}]) \\
    \end{pmatrix}
$$

</small>

---

# 복합 자료형 : `dict`

$$
    \begin{pmatrix}
    (\text{스포츠}, [\text{스포츠 글 1}, \text{스포츠 글 2}, \dots, \text{스포츠 글 n}]) \\
    (\text{패션}, [\text{패션 글 1}, \text{패션 글 2}, \dots, \text{패션 글 n}]) \\
    (\text{파이썬}, [\text{파이썬 글 1}, \text{파이썬 글 2}, \dots, \text{파이썬 글 n}]) \\
    \end{pmatrix}
$$

3. 위 형식을 딕셔너리로 옮기면 아래와 같이 옮길 수 있음:

```python
블로그_글: dict = {
    "스포츠": ["스포츠 글 1", "스포츠 글 2", ..., "스포츠 글 n"],
    "패션": ["패션 글 1", "패션 글 2", ..., "패션 글 n"],
    "파이썬": ["파이썬 글 1", "파이썬 글 2", ..., "파이썬 글 n"]
}
```

---

# 복합 자료형 : `dict`

```python
블로그_글: dict = {
    "스포츠": ["스포츠 글 1", "스포츠 글 2", ..., "스포츠 글 n"],
    "패션": ["패션 글 1", "패션 글 2", ..., "패션 글 n"],
    "파이썬": ["파이썬 글 1", "파이썬 글 2", ..., "파이썬 글 n"]
}
```

위 선언 코드를 사용하면 다음과 같이 코드를 작성할 수 있음

```python
# 1. '스포츠' 관련 게시글 찾아보기 (큰 따움표, 작은 따움표 여부는 무관합니다)
블로그_글["스포츠"]
블로그_글['스포츠']
# 2. '패션' 관련 게시글 찾아보기
블로그_글['패션']
# 3. '패션' 글을 3번째부터 가져오기
블로그_글['패션'][3:]
# 4. '패션' 분류의 2번째 글 수정하기
블로그_글['패션'][2] = "패션은 어려워"
```

---

# 연산자 지도

- 산술 연산자: +, -, *, /, // (정수 나눗셈), % (나머지), ** (거듭제곱)
- 할당 연산자: =, +=, -=, *=, /=, //= (정수 나눗셈 후 할당), %= (나머지 후 할당), **= (거듭제곱 후 할당), &=, |=, ^=, <<=, >>=
- 비교 연산자: ==, !=, >, <, >=, <=
- 논리 연산자: and, or, not
- 별 연산자 (asterisk operator): *, **
- 비트 연산자: & (비트 AND), | (비트 OR), ^ (비트 XOR), ~ (비트 NOT), << (비트 왼쪽 시프트), >> (비트 오른쪽 시프트)
- 멤버십 연산자: in, not in
- 식별 연산자: is, is not

---

# 산술 연산자

산술 연산자:+, -, *, /, // (정수 나눗셈), % (나머지), ** (거듭제곱)

수학적으로 사용할 수 있는 연산자 (문자열에도 적용 가능한데, `문자열 연산`이라고 부름)
:warning: 예시에서는 이미 다 알고 있을 사칙연산은 제외함

```python
# 거듭제곱
2 ** 3  # 8
2 ** 4  # 16
# 몫과 나머지
5 // 3  # 1
5 % 3  # 2
5 / 3  # 1.6666666666666667
# 문자열 연산 (곱하기랑 더하기만 가능)
"abc" * 3  # "abcabcabc" | 문자열 반복
"abc" + "def"  # "abcdef" | 문자열 덧셈(병합)
```

---

# 할당 연산자

할당 연산자는 `편의성 연산자` 입니다.
산술 연산자, 비트 연산자와 연관지어 사용할 수 있으며, 다음과 같은 형태로 사용할 수 있습니다.

```python
<대상 변수> <사용할 산술 연산자/비트 연산자>= <연산할 값>

# 예시
a: int = 3
a += 10  # 13 (대상 변수: a, 사용할 산술 연산자: +, 연산할 값: 10)
a *= 5  # 15 (대상 변수: a, 사용할 산술 연산자: *, 연산할 값: 5)
a &= 10  # 2 (대상 변수: a, 사용할 비트 연산자: &, 연산할 값: 10)
문자열: str = "HELLO"
문자열 *= 3  # "HELLOHELLOHELLO" (문자열 연산도 가능)
```

---

# 비교 연산자

`일치 비교`과 `대소 비교`로 구분되는 연산자입니다.
일치 여부를 비교하는 `==`와 불일치 여부를 비교하는 `!=`.
대소 비교를 하는 `<`, `>`, `<=`, `>=`가 있습니다.

```python
# 형식
a == b  # a와 b의 값이 일치한지 비교합니다. (일치하면 True, 아니면 False)
a != b  # a와 b의 값이 불일치한지 비교합니다. (일치하면 False, 아니면 True)
3 == 3  # True
10 == 3  # False

a > b  # a 보다 b가 큰 지 비교
a < b  # a 보다 b가 작은지 비교 
a >= b  # a 보다 b가 크거나 같은지 비교
a <= b  # a 보다 b가 작거나 같은지 비교
```

---

# 논리 연산자

2가지 이상의 논리식, 논리값에 대해 논리 연산을 지원하기 위한 연산자입니다.
`and`, `or`, `not` 입니다. 각각 다른 언어에서의 `&&`, `||`, `!`와 혼용될 수 있습니다.

```python
# 논리식과 논리값 예시
a == b  # 논리 식
a != b  # 논리 식
True  # 논리 값
False  # 논리 값

# 연산자 형식과 의미
a and b  # a와 b 논리 식/값이 모두 참인가 (맞다면 True, 아니면 False)
a or b  # a와 b 논리 식/값 중 하나 이상이 참인가 (맞다면 True, 아니면 False)
not a  # a 논리 식/값을 반전시킵니다.
```

---

# 논리 연산자 예시

```python
a: int = 10
# not 예시
not True  # False
not False  # True
not a == 10  # False
# and 예시
True and True  # True
False and True  # False
a == 10 and True  # True
# or 예시
False or True  # True
False or False  # False
a ** 2 == 100 or True  # True
```

---

# 별 연산자 (asterisk operator, \*, \*\*)

<small>

별 연산자는 어떤 변수를 **풀어서 쓰는 연산자** 입니다. 개발자 편의를 위한 연산자 중 하나입니다.

```python
# 리스트에서:
a: list = [1, 2, 3]
b: list = [*a]  # [1, 2, 3] | a 풀어서 리스트 형성한 후, b에 저장하기
c: tuple = (*a)  # (1, 2, 3) | 튜플도 가능
# 딕셔너리에서:
d: dict = {
    "A": "I'm A",
    "B": "I'm B"
}
list_d: list = [*d]  # ["A", "B"] | '키', '값' 중 '키'만 가져온 상태
dictionary_d: list = {**d}  # { "A": "I'm A", "B": "I'm B" } | 원본과 같은 형식!
```

</small>

---

# 별 연산자 (asterisk operator, \*, \*\*) 실습

아래 코드에서 c와 d에 저장될 값을 예측하시오.

```python
a: dict = {
    "A": "I'm A",
    "P": "Pork Belly 맛있어요"
}
b: dict ={
    "B": "I'm B",
    "G": "You're Genius"
}
c: dict = {**a, **b}
d: list = {*a, *b} 
```

---

# 비트 연산자

비트 연산자는 어떠한 숫자를 비트 단위로 연산하기 위한 연산자입니다.
예를 들어 숫자 10은 2진법으로 1010이며, 숫자 7은 2진법으로 111 입니다.
a가 10, b가 7이라고 가정했을 때 결과는 다음과 같습니다.

```python
a & b  # 2 (10) | AND 비트 연산
a | b  # 15 (1111) | OR 비트 연산
a ^ b  # 13 (1101) | XOR 비트 연산
~a  # -11(-1011) | NOT 비트 연산
a << 1  # 20 (10100) | LEFT SHIFT 비트 연산 | 2 곱해짐
a >> 1  # 5 (101) | RIGHT SHIFT 비트 연산 | 2 나눠짐
```

---

# 멤버십 연산자

리스트, 튜플 내에 변수가 소속되었는가를 알기 위한 연산자

```python
<변수값> in <리스트/튜플>  # 리스트/튜플 내에 변수값이 존재하는가를 확인하는 변수
<변수값> not in <리스트/튜플>  # 리스트/튜플 내에 변수값이 존재하지 않는가를 확인하는 변수
# 예시
3 in [1, 2, 3]  # True | 3이 [1, 2, 3] 내에 포함되어 있어서 True
101 in (1, 2, 3)  # False | 101이 (1, 2, 3) 내에 포함되어 있지 않아 False
101 not in (1, 2, 3)  # True | 101은 (1, 2, 3) 내에 없어서 True
not (101 in (1, 2, 3))  # True | 101이 (1, 2, 3) 내에 포함되어 있지 않지만, not이 `not in`의 효과를 내어 True
```
---

# 식별 연산자

<small>

파이썬에는 `포인터`라는 개념이 명시적으로 존재하지 않지만, 파이썬의 변수 또한 할당을 위해서 램으로부터 주소를 할당 받아야 합니다.
식별 연산자 `is`, `is not` 연산자는 주소를 비교하여 같은 객체, 같은 변수인지 비교합니다.
"같은 주소에 저장된 변수는 같은 변수이다"라고 판단합니다.

`id(변수)`를 통해 주소를 직접 확인할 수도 있습니다.

```python
a: int = 3  
b: int = a  
c: int = 1001  

print(id(a))  # 140692912030000
print(id(b))  # 140692912030000
print(id(c))  # 140692891013264

print(a is b)  # True
print(a is c)  # False
```

</small>

---

# 흐름 제어
 
- if, elif, else 조건문
- while 반복문
- for 반복문

---

# if, elif, else 조건문

`if`, `elif`, `else`는 복수 개의 조건을 통해 프로그램의 흐름을 제어하기 위한 문법입니다.
형식은 다음과 같습니다:

```python
if <조건 1>:
    # <조건 1>에 맞는 실행 내용
elif <조건 2>:
    # <조건 2>에 맞는 실행 내용
elif <조건 ...>:
    # <조건 ...>에 맞는 실행 내용
elif <조건 n>:
    # 조건 n>에 맞는 실행 내용
else:
    # 위 n개의 조건이 모두 거짓인 경우의 실행 내용
```

---

# if, elif, else 조건문 예시: '80자 이상의 길이를 가진 글은 뒤에 ...으로 대체해서 출력하기'

```python
문자열 = "aabbccddeeff" * 10  # 10글자 * 10 해서 100글자 만들기
if len(문자열) >= 80:
    print(문자열[:80] + "...")
else:
    print(문자열)
```

---

# if, elif, else 조건문 예시 : 유기적인 조건 연계 (else의 사용)

**예시**: 3으로 나누었을 때 나머지가 0, 1, 2 중 어느 것인가

```python
n: int = 100
if n % 3 == 0:
    print(str(n) + "은 3으로 나누어 떨어집니다")
elif n % 3 == 1:
    print(str(n) + "은 3으로 나누었을 때 1이 남습니다")
elif n % 3 == 2:
    print(str(n) + "은 3으로 나누었을 때 2가 남습니다.")
```

```python
n: int = 100
if n % 3 == 0:
    print(str(n) + "은 3으로 나누어 떨어집니다")
elif n % 3 == 1:
    print(str(n) + "은 3으로 나누었을 때 1이 남습니다")
else:  # 위의 조건문에 따라 `else`에 도달 했을 때 n의 값은 3으로 나누었을 때 나머지가 2인 숫자만 이 곳에 도착합니다
    print(str(n) + "은 3으로 나누었을 때 2가 남습니다.")
```

---

# while문

while문은 **조건문의 형식을 갖춘 반복문** 입니다.
while문은 **조건이 거짓이 될 때까지**, **조건이 참이면 항상** 동작합니다.

```python
## 형식
while <조건>:
    # 실행 내용

# 예시
i: int = 1
while i <= 3:
    print(i)
```

---

# for문
 
<small>

> **다른 언어와 파이썬 언어에서의 for문 개념 차이**
> 다른 언어에서 for문은 `초기자`, `조건자`, `증감자`를 갖춰 정해진 틀 없이 자유롭게 짤 수 있습니다.
> 파이썬 언어에서는 정해진 배열을 모두 순회하면 끝나는 개념입니다.

</small>

<div class="pure-g">
    <div class="pure-u-1-2">
<pre>
<code>
// C언어 코드
for (int i = 0; i < 10; i++) {
    printf("%d\n", i);
}
</code>
</pre>
    </div>
    <div class="pure-u-1-2">
<pre>
<code>
# 파이썬 코드
for i in [1, 2, 3]:
    print(i)
</code>
</pre>
    </div>
</div>

---

# for문 기본 예시

파이썬에서 for문은 정해진 배열을 모두 순회하면 끝나는 개념입니다.

예시코드: 

```python
for 리스트_값 in [1, 2, 3]:
    print(리스트_값)
```

출력:

```
1
2
3
```

---

# for문 활용 문법 : `range` : 연속된 숫자 배열 만들기

파이썬의 for문은 정해진 배열을 처음부터 끝까지 순회하고 끝나는 개념이기 때문에, 어떤 값을 가공하여 특정한 객체를 만드는 구현체가 존재합니다.
대부분의 교재에서 소개하는 가장 기본적인 구현체인 `range`부터 소개합니다.

```python
# 기본 형태
range(min, max, step)  # min부터 max까지 step씩 증가하는 수열이 만들어집니다 (min 기본값: 0, step 기본값: 1)

range(10)  # == range(0, 10, 1) | list(range(10)) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
range(3, 5)  # == range(3, 5, 1) | list(range(3, 5)) == [3, 4]
range(3, 10, 3)  # == range(3, 10, 3) | list(range(3, 10, 3)) == [3, 6, 9]
```

---

# for문 활용 문법 : `range` : 연속된 숫자 배열 만들기 실습

실제 예상대로 동작하는지 확인해보세요

```python
for i in range(10):
    print(i)

for i in range(3, 5):
    print(i)

for i in range(3, 10, 3):
    print(i)
```

---

# for문 활용 문법 : 리스트 순회와 번짓수 확인을 동시에, `enumerate`

```python
# 배경지식: 튜플은 서로 다른 변수에 쪼개서 저장할 수 있습니다.
a, b, c = (1, 2, 3)  # a = 1, b = 2, c = 3과 같은 역할
```

```python
리스트: list = [1, 2, 3]
# 코드 비교: range vs. enumerate
for 번짓수 in range(len(리스트)):
    값 = 리스트[번짓수]
    print(번짓수, 값)

for 번짓수, 값 in enumerate(리스트):
    print(번짓수, 값) 
```

---

# for문 활용 문법 : `enumerate` 개념 짚고가기

```python
# 실습
list(enumerate([1, 2, 3]))  # [(0, 1), (1, 2), (2, 3)]
list(enumerate(['a', 'b', 'c']))  # [(0, 'a'), (1, 'b'), (2, 'c')]

for 번짓수, 값 in enumerate(['a', 'b', 'c']):
    print(번짓수, 값)
# 예시 출력:
# 0 a
# 1 b
# 2 c
```

---

# for문 활용 문법 `zip`

```python
a: list = [1, 2, 3]
b: list = ['a', 'b', 'c']
c: list = ['A', 'B', 'C']

list(zip(a, b, c))  # [(1, 'a', 'A'), (2, 'b', 'B'), (3, 'c', 'C')]
for 값1, 값2, 값3 in list(zip(a, b, c)):
    print(값1, 값2, 값3)

# 예시 출력:
# 1 a A
# 2 b B
# 3 c C
```